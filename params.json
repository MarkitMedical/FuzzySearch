{"name":"FuzzySearch","tagline":"Autocomplete suggestion provider using approximate string matching","body":"FuzzySearch.js\r\n=====================\r\n\r\nWhat is FuzzySearch.js ?\r\n-----------------------\r\n\r\nIt is an approximate string matching library with focus on search and especially suggest-as-you-type auto-complete. The suggestion engine is compatible with twitter type-ahead and can be used instead of a bloodhound object. This library / suggestion engine do not have nay dependency. It is also focused on string processing and will not do ajax call by itself.\r\n\r\nIt perform three kind of operation:\r\n\r\n1. Searching\r\n\r\n    Perform the scoring operation on all item keyword.  \r\n    Manage logic of why an item would have a better overall score than another given multiple axproximately matched keyword\r\n\r\n2. Scoring\r\n\r\n    Given two word how clore are they ?  \r\n    Is word A closer to B or to C ? Is Match(A,B) worth less or more than Match(C,D) ?  \r\n    We try to answer those question in an autcomplete scenario. Error in what is already typed probably worth more than a character not yet typed.\r\n    This would not be the case in a spellchecker setup for example.\r\n\r\n\r\n2. Highlighting\r\n\r\n    Highlight is provided on demand. First best 1:1 pairing between query and field tokens is computed. Then we compute matching characters between the two tokens, taking special care to output the most compact match when multiple one are possible.\r\n\r\nCan I see a demo ?\r\n------------------\r\n\r\n [You can view the demo page here](https://cdn.rawgit.com/jeancroy/FuzzySearch/master/demo/autocomplete.html)\r\n\r\nIs this based on edit distance ?\r\n--------------------------------\r\nShort answer: No. Medium answer: Sort of. Long answer: there's a whole section below about how we calculate a score.\r\n\r\nAll this to say, this provide a different scoring than typical levenshtein distance, it might be better or worse suited to your application. For example in suggest-as-you-type scenario it might be better to show vague suggestion than nothing. For situation where we ask if two things are the same (person, address, etc) it might be better to have more strict positive matches.\r\n\r\n\r\nWhat is LCS ?\r\n----------------------\r\nLongest common sub-sequence. Shared character between two string in the right order. lcs(survey, surgery) = surey.\r\n\r\nComputer science often think similarity between two string in term of error (distance). And computational biology in term of matches. (We can view matching in Proteins, DNA, etc as a string problem).\r\n\r\nThey are related but different problem and the bet of this project is that LCS could be useful for auto-complete scenario (with some help). As a bonus it's often faster to compute.\r\n\r\n\r\nBasic usage\r\n=====================\r\n\r\nMinimalist\r\n----------\r\n\r\nBasic usage is to create an object that specify the data and keys to be indexed\r\nThen use the method search to perform a search\r\n\r\n```javascript\r\n    var data = [\"survey\",\"surgery\",\"insurgence\"];\r\n    var searcher = new FuzzySearch({source:data, output_map:\"item\"});\r\n    var query = \"assurance\";\r\n    var result = searcher.search(query)\r\n```\r\n\r\nTwitter typeahead\r\n----------------\r\n\r\nFuzzySearch support the \\__ttAdapter interface so it can be used instead of a BloodHound object. Setting no output filter output an abject with all match detail (score, matched field, original item) highlight is provided on demand, here we use it at template construction time\r\n\r\n```javascript\r\nvar books = [{\"title\":\"First Book\", \"author\":\"John Doe\"}, {\"title\":\"...\", \"author\":\"...\"}];\r\nvar fuzzyhound = new FuzzySearch({source:data, keys:[\"title\",\"author\"], output_map:\"\" });\r\n\r\n$('#typeahead-input').typeahead({ minLength: 2 }, {\r\n    name: 'fuzzyhound',\r\n    source: fuzzyhound,\r\n    display: \"item.title\",\r\n    templates: {\r\n        suggestion: function (suggestion) {\r\n            var item = suggestion.item;\r\n            var query = suggestion._query;\r\n            return [\r\n                \"<div>\",\r\n                \"<span class='title'>\", fuzzyhound.highlight(query, item.title), \"</span>|\",\r\n                \"<span class='author'>\", fuzzyhound.highlight(query, item.author), \"</span><br>\",\r\n                \"<span class='score'>( \", suggestion.match, \" : \", suggestion.score.toFixed(2), \" )</span>\",\r\n                \"</div>\"\r\n\r\n            ].join(\"\");\r\n        },\r\n        notFound: function (context) {\r\n            return \"<div class='typeahead-empty'> No result for \\\"\" + context.query + \"\\\"</div>\"\r\n        }\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\nScoring overview\r\n=====================\r\n\r\nGeneral principle is to be very flexible in finding a match, prefer return a loose match than nothing, but give higher score when we do not need the flexibility (more exact match)\r\n\r\nScoring an item\r\n----------------\r\n\r\nFuzzySearch support quite complex items, query is compared to specified field.\r\n\r\n```javascript\r\n    book = {\r\n        Title: \"Cliché à Paris, The\",\r\n        Year: 1977,\r\n        Author: \"John MiddleName Doe\",\r\n        Keywords:[\"Story\",\"Boy\"],\r\n        Reference:{ISSN:\"00-11-22\", ARK:\"AA-BB-CC\"},\r\n        Available:4\r\n    }\r\n```\r\n\r\n### Collect information (And normalize)\r\n\r\n```javascript\r\nkeys = [\"Title\",\"Author\",\"Year\",\"Keywords\",\"Reference.ISSN\"]\r\n```\r\n\r\nFirst thing we do is to build a list of field value, normalized to lowercase and with some common accent removed. If field is an array all it's sub elements are inserted. Values are inserted for a key value map.\r\nWe support path (things.this.that).\r\n\r\n```javascript\r\nFields = [\"cliche a paris, the\",\"john middlename doe\",\"1977\",\"story\",\"boy\",\"00-11-22\"]\r\n```\r\n\r\n### Field priority\r\n\r\nIt often make send to give more weight to the title than first keyword,\r\nmore weight to first keyword than second and so on.\r\n\r\nThis is achieved using an exponentially decaying bonus. First item have twice the score then bonus decay to one. This is it give a marked difference between first and second item and not so much item 4th going on.\r\n\r\nParameter (`d = bonus_position_decay`) control the decay:\r\n```javascript\r\nbonus = 1.0+d^n\r\n```\r\n\r\n|Position          | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8    |\r\n|------------------|-----|-----|-----|-----|-----|-----|-----|-----|------|\r\n|Bonus (d=0.5)     | 2.0 | 1.5 | 1.25| 1.13| 1.06| 1.03| 1.02| 1.01| 1.003|\r\n|Bonus (d=0.7071)  | 2.0 | 1.7 | 1.5 | 1.35| 1.25| 1.18| 1.13| 1.09| 1.063|\r\n\r\n\r\n### Free word order\r\n\r\nOften words keep their meaning even when out of order.\r\nThose will all match the author keyword:\r\n\r\n    John Doe\r\n    Doe John\r\n    John doe Midle\r\n\r\nAnother example where free word order is useful would be natural language query:\r\nMatch:  `How to paint my wall ?` against `Wall painting 101`\r\n\r\nFlip side of allowing free word order is preferring properly ordered words. This is done by giving a bonus of (`bonus_token_order`) each time two consecutive token in the query are in order in the match\r\n\r\n### Multiple field matching\r\n\r\n> cliche 1977\r\n\r\nThis query would match in both `title` and `year` field.\r\nFlip side of allowing Multiple field matching is giving preference to words in the same field:\r\n\r\n >\"john doe\", two word, same field\r\n\r\nScore is average of\r\n 1. best score, every query token on the best field for the item\r\n 2. best score, every query token on any field (their best field)\r\n\r\n### Output score thresholding\r\n\r\nDefault value are for suggestion as you type. In this case we prefer to show poor matches than nothing, match will improve as we type more.\r\n\r\n> Parameter `thresh_include` control the minimum score to show\r\n\r\nWe also want to limit choices to a good match or a few good matches if those exist. For example if the best score is twice as good as the next best one, it's obviously the candidate to show.\r\n\r\n> Parameter `thresh_relative_to_best` control ratio of best match needed to be shown on the list\r\n\r\nLastly if an item have multiple keyword, we might want to stop searching once we have found a good keyword. If a match is this good it'll be shown, no matter the best threshold.\r\n\r\n> Parameter `field_good_enough` control the score needed to stop the search on this item. It also control forced inclusion, not matter best\r\n\r\n\r\n\r\n### Output map\r\n\r\n#### Full detail\r\n\r\nSetting `outputmap=\"\"` return the object as we use internally for sorting and scoring\r\n\r\n```javascript\r\n    candidate = {\r\n        score:8.1,\r\n        item:{}, //original item\r\n        match:\"1977\",\r\n        matchIndex:2\r\n    }\r\n```\r\n\r\n#### Original detail\r\n\r\nSetting `outputmap=\"item\"` give you back original item as given to the algorithm. This indicate you do not need all match detail and allow to skip some step (like finding original spelling of matching field)\r\n\r\n#### Property of an original item\r\n\r\nIf you only need the id or title of the original item you can do it like that `outputmap=\"item.property\"`\r\n\r\n\r\n\r\nScoring a token (in a auto-complete friendly manner)\r\n--------------------------------------------------\r\n\r\nThere's two main way to count string similarity one is to count the number of matches the other one is to count the number of error. Those refer to the length of the longest common sub-sequence and the edit distance problem. (Here we'll consider only the simple edit distance with only insertion/deletion )\r\n\r\nMatch are show with \"|\" and error are show with \"-\"\r\n\r\n    sur-ve-y\r\n    |||  | |\r\n    surg-ery\r\n\r\nmatch: 5, error: 3\r\n\r\n\r\nBoth are related, but when comparing score of different length they can lead to different conclusions.\r\n\r\n    match(\"uni\",\"university\") : match 3, error 7\r\n    match(\"uni\",\"hi\") : match 1, error 2\r\n\r\nFirst pairing have more match, second pairing have less error.\r\nMost algorithm available use edit distance (error)\r\nyet somehow uni -> university is a intuitive match.\r\n\r\n### Looking at relative errors\r\n\r\nOne way to deal with different match length is to normalize error count by the length. Which one? Let's try to compare error count with length of second term...\r\n\r\n    match(\"uni\",\"university\") : 7 error/10 char = 0,7 error/char\r\n    match(\"uni\",\"hi\") : 2 error/3 char = 0,666 error/char\r\n\r\nSecond match still have a lower relative error count.\r\nEven worse, the number of relative error are very close...\r\n\r\n    match(\"uni\",\"universit\") : 6 error 9 char, 0,666 error/char\r\n    match(\"uni\",\"universi\") : 5 error 8 char, 0,625 error/char\r\n\r\nAt that point pairing decision is now reversed. Relative error is not a very stable score.\r\n\r\n### Different similarity metric\r\n\r\n**Simple edit distance** consider only count the number of insert / delete operation needed to go from string A to string B. For example type/typo are at a distance of 2: `del[e], ins[o]`.\r\n\r\n**Levenshtein edit distance** add substitution.  For example type/typo are at a distance of 1: `subs[e,o]`. It improve over simple distance that wrong character error are not penalized twice. However it loose the ability to prefer transposition.\r\n\r\n**Damerau edit distance** add transposition operation. This has make a metric that do not over penalize substitution, but also prefer word that had letter swapped (not that simple edit distance had that transposition preference too)\r\n\r\nEach time we add operation we have the opportunity to better model the error, but it add computation cost\r\n\r\n#### Edit distance (lower is better)\r\n\r\n|Distance | ed | BULB / BOOB | ed | BULB / BLUB |\r\n|:---------|----|-------------|----|-------------|\r\n| Simple  | 4  |  `B--ULB Ins[OO]`<br> `BOO--B Del[UL]` | 2 |` B-ULB Ins[L]` <br> `BLU-B Del[L]` |\r\n| Levenshtein   | 2  |  Subs[U,O]<br>Subs[L,O] | 2 | Subs[U,L]<br>Subs[L,U] |\r\n| Damerau | 2 | Subs[U,O]<br>Subs[L,O] | 1 | Transpose[U,L] |\r\n\r\n#### Matching characters (LCS, higher is better)\r\n\r\n|Metric | L | BULB / BOOB | L | BULB / BLUB |\r\n|:------|---|-------------|---|-------------|\r\n| length of lcs  | 2  | BB | 3 | BUB or BLB |\r\n\r\n\r\nThis metric is interesting for a number of reason. First we can remember the above case of `match(\"uni\",\"university\")` vs `match(\"uni\",\"hi\")` : intuitively we tend to count match rather than errors. Then this comparison show that counting match result in a scoring similar to Damerau-Levenshtein. No over-penalty on substitution and partial score for transposition.\r\n\r\nPossibly more interesting, length of LCS is fast to compute. Similar in complexity than simple edit distance. Indeed, if we set `m: length of string A`, `n: length of string B`, `ed: simple edit distance with unit cost`. `llcs:length of lcs`, we have:\r\n\r\n> 2*llcs = m + n - ed\r\n\r\nSo basically we can learn from that than:\r\n - If we have either llcs or simple edit distance we can get compute the other.\r\n - The 2 in front of llcs is the reason we do not double penalize substitution.\r\n\r\nPlease note that while `find the longest subsequence between A and B` and `find the shortest edit distance between A and B` are equivalent while comparing all of A versus all of B (Global match). They are not equivalent while comparing part of A versus part of B (Local match) or all of A versus part of B (Semi-Global, search a needle in a haystack). This explain that they are different research topic with different typical use.\r\n\r\nFurthermore, the resulting score are not equivalent while sorting a list of possible matches of varying length. This is the point we tried to make while comparing `\"uni\"` to `[\"hi\",\"university\"]`. The hypothesis behind this project is that counting matches is more intuitive and should better match user expectation in an interactive user interface.\r\n\r\n##### But, is there a catch ?\r\n\r\nWhere simple edit distance can be overly severe, llcs can be overly optimistic.\r\nMatching 3 out of 4 character, or matching 3 out of 40 both give a score of 3.\r\nTo some extend we want this (better to show something than nothing).\r\nBut, we also want to give better score to better match, so we have to find to include back some information about error.\r\n\r\n### Looking for a score relative to input length\r\n\r\nLet's consider those three cases:\r\n\r\n```javascript\r\n    match(\"uni\",\"university\")     // case 1\r\n    match(\"unicorn\",\"university\") // case 2\r\n    match(\"uni\",\"ultra-nihilist\") // case 3\r\n```\r\n\r\nLet m be the number of matches\r\n\r\n- If we compare m to second word length,\r\n\t- we cannot differentiate case 1 and 2. (3/10)\r\n- we compare m to first word length,\r\n\t- we cannot differentiate case 1 and 3. (3/3)\r\n- If we compare m to average of both length,\r\n\t-  we cannot differentiate case 2 and 3 !! (3/8.5)\r\n\r\nFrom that we learn that we want to include both length, but not in the form of arythmetic average of both. We need to do more research !\r\n\r\n#### Jaro–Winkler distance\r\n\r\nThe [Jaro–Winkler distance ](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) is an heuristic algorithm for string matching. It's fast and perform well in different comparison.  In particular the *Jaro* distance use an approximation of LCS and then report it back to a score ranging from 0-1, combining length of both string. *Wrinkler* add the idea to give a bonus for common prefix, prefix bonus looks like something that fit well in a auto-complete scenario.\r\n\r\nLet's examine a jaro like score: let `m: be number of matches`, `sa: size of a`, `sb: size of b`.\r\n\r\n    score = (m/sa + m/sb) /2;\r\n\r\nThis has some interesting properties:\r\n\r\n - better score if we match more of a.\r\n - better score if we match more of b.\r\n - minimum score is m/(2a) even if b is infinitely large.\r\n\r\nWe do not have access to a number of transposition like *Jaro*, BUT lcs restrict matches to those that are in correct order, so we have some transposition effect built-in the value of llcs.\r\n\r\n#### Prefix\r\n\r\nThere's some very efficient way to compute number of matches between two string, but most of them rely on simplifying the original problem. One such simplification is to only store the score and not the different possible path possible to reach that score.\r\n\r\nOn the flip side, human most often input start of word rather than something in the middle. Prefix is a common sub-string of both inputs that start at first character. It's fast to compute, and allow to shrink the problem size for llcs computation. We'll add some bonus for common prefix controlled by `bonus_match_start`. That's the Winkler like part of our scoring algorithm.\r\n\r\nCompromise of using exact prefix is that a typo at the start of the word will stop  match, so it can induce a heavy penalty.\r\n\r\n#### Matching multiple keywords\r\n\r\nFor matching a single token, we have a pretty interesting solution. However testing revealed that this scoring scheme gave disproportionate importance to small words. For example matching perfectly `of` or matching perfectly `Honorificabilitudinitatibus` both give a score of 1. However one is clearly easier to match than the other.\r\n\r\nWe'll use the match length as a shortcut to specificity. (Doing this, we assume common words are short to use least amount of effort for a specific communication need).\r\n\r\nWe multiply Jaro-like score by llcs and the score become:\r\n```javascript\r\n\tscore = 0.5*m*(m/sa + m/sb)  + bonus*prefix;\r\n```\r\n\r\nHaving m squared give the advantage of even better score for good matches and worse score for bad match. It lower the likelihood of multiple bad match out-score a single good match. A character matched in a good token is now worth more than a character matched in a bad token.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration\r\n==============\r\n\r\n\r\n| Parameter                | Default | Description |\r\n|:--------------------------|---------|-------------|\r\n| minimum_match            | 1.0     | Minimum score to consider two token are not unrelated |\r\n| thresh_include           | 2.0     | To be a candidate score of item must be at least this |\r\n| thresh_relative_to_best  | 0.5     | and be at least this fraction of the best score |\r\n| field_good_enough        | 20      | If a field have this score stop searching other fields. (field score is before item related bonus) |\r\n| bonus_match_start        | 0.5     | Additional value per character in common prefix |\r\n| bonus_token_order        | 2.0     | Value of two token properly ordered |\r\n| bonus_position_decay     | 0.7     | Exponential decay for position bonus (smaller: more importance to first item) |\r\n| score_round              | 0.1     | Two item that have the same rounded score are sorted alphabetically |\r\n| output_match_detail      | true    | if false output original item if true output {score:...item:...match:... matchIndex:...} |\r\n| cache_fields             | true    | Perform the \"collect\" step only once and store result. Save computation time but use duplicate indexed fields  |\r\n| max_search_tokens        | 10      | Because of free word order each search token add cost equivalent to one traversal additional tokens are lumped as a nth+1 token|\r\n| max_candidates           | 100     | Stop search after that many good candidate found Will trigger a recount to enforce relative_to_best rule|\r\n| highlight_prefix         | false   | true: force prefix as part of highlight (false: minimum gap slower)|\r\n| highlight_bridge_gap     | 2       | display small gap as substitution set to size of gap 0 to disable|\r\n| highlight_tk_max_size    | 64      | max size of a token for highlight algorithm (it is BVMAXSIZE(31) for search)|\r\n| highlight_before         | ...     |   tag to put before the highlight <br> `default: <strong class=\"highlight\">`|\r\n| highlight_after          |  ...    | after the highlight <br> `default: </strong>`   |\r\n\r\n\r\n\r\nAlgorithms\r\n==========\r\n\r\nMain bitvector algorythm\r\n\r\n> A fast and practical bit-vector algorithm for the longest common sub-sequence problem (Crochemore 2001)\r\n> igm.univ-mlv.fr/~mac/REC/DOC/01-lcs_ipl.ps\r\n>\r\n> Bit-parallel LCS-length computation revisited (Hyyrö 2004)\r\n> http://www.sis.uta.fi/~hh56766/pubs/awoca04.pdf\r\n\r\nLarge string algorithm (used when previous algorithm would require >32 bit)\r\n\r\n> An input sensitive online algorithm for LCS computation (Hyyrö 2009)\r\n> http://www.stringology.org/event/2009/p18.html\r\n> http://www.stringology.org/event/2009/psc09p18_presentation.pdf\r\n\r\nPack multiple token into a single parallel computation\r\n\r\n> Increased Bit-Parallelism\r\n> for Approximate and Multiple String Matching (Hyyrö 2006)\r\n> http://www.dcc.uchile.cl/~gnavarro/ps/jea06.pdf\r\n\r\nSequence alignment (highligth)\r\n> Smith Waterman Gotoh\r\n> http://www.bioinf.uni-freiburg.de/Lehre/Courses/2014_SS/V_Bioinformatik_1/gap-penalty-gotoh.pdf\r\n> http://telliott99.blogspot.ca/2009/08/alignment-affine-gap-penalties_08.html\r\n\r\nCompaison of some string similarity\r\n> https://asecuritysite.com/forensics/simstring\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}