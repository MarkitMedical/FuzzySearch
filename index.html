<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>FuzzySearch by jeancroy</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">FuzzySearch</h1>
        <p class="header">Autocomplete suggestion provider using approximate string matching</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/jeancroy/FuzzySearch/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/jeancroy/FuzzySearch/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/jeancroy/FuzzySearch">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/jeancroy">jeancroy</a></p>


      </header>
      <section>
        <h1>
<a id="fuzzysearchjs" class="anchor" href="#fuzzysearchjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>FuzzySearch.js</h1>

<h2>
<a id="what-is-fuzzysearchjs-" class="anchor" href="#what-is-fuzzysearchjs-" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is FuzzySearch.js ?</h2>

<p>It is an approximate string matching library with focus on search and especially suggest-as-you-type auto-complete. It support complex input as well as simple list of string and allow you to match item as sentences rather than single words. In addition to searching, we provide on demand Sublime Text like highlight (including free word order on highlight).  The suggestion engine is made to be compatible with multiple UI including <a href="https://twitter.github.io/typeahead.js/">twitter typeahead</a> and can be used instead of a <a href="https://github.com/twitter/typeahead.js/blob/master/doc/bloodhound.md">bloodhound</a> object. This library is focused on string processing and do not have any dependency.</p>

<h2>
<a id="can-i-see-a-demo-" class="anchor" href="#can-i-see-a-demo-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Can I see a demo ?</h2>

<p>You can view the main demo page <a href="https://rawgit.com/jeancroy/FuzzySearch/master/demo/autocomplete.html">here</a><br>
 If you want to see a simple minimal setup, it's <a href="https://rawgit.com/jeancroy/FuzzySearch/master/demo/simple.html">here</a> </p>

<h2>
<a id="why-a-suggestion-engine-" class="anchor" href="#why-a-suggestion-engine-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why a suggestion engine ?</h2>

<p>Many fuzzy string project are basically a scoring algorithm with a loop to apply it on a list of string. Treating each string as a single word to match. This is perfect for spell checking scenario, but can be insufficient if we deal with object or sentences/expression rater than words. </p>

<p>This project add infrastructure to accept about any kind of input and loop the scoring algorithm over each words of specified field of your objects. Including field that are array (for example a list of keywords or a list of authors). Then It'll put together a score that take into account the multiple words or multiple fields that matches. Finally it'll allow you to transform the output to your liking for display. </p>

<p>We aim to be a plug-and-play approximate string matching suggestion engine, you provide your favourite search-box/select-box UI library and we provide data crunching for your query to give you quality matches.</p>

<h1>
<a id="basic-usage" class="anchor" href="#basic-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic usage</h1>

<h2>
<a id="minimalist" class="anchor" href="#minimalist" aria-hidden="true"><span class="octicon octicon-link"></span></a>Minimalist</h2>

<p>Basic usage is to create an object that specify the data and keys to be indexed
Then use the method search to perform a search</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-k">var</span> data <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>survey<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>surgery<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>insurgence<span class="pl-pds">"</span></span>];
    <span class="pl-k">var</span> searcher <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FuzzySearch</span>({source<span class="pl-k">:</span>data});
    <span class="pl-k">var</span> query <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>assurance<span class="pl-pds">"</span></span>;
    <span class="pl-k">var</span> result <span class="pl-k">=</span> searcher.<span class="pl-c1">search</span>(query)</pre></div>

<h2>
<a id="twitter-typeahead" class="anchor" href="#twitter-typeahead" aria-hidden="true"><span class="octicon octicon-link"></span></a>Twitter typeahead</h2>

<p>FuzzySearch support the <code>__ttAdapter</code> interface so it can be used instead of a BloodHound object. Setting no output filter output an abject with all match detail (score, matched field, original item) highlight is provided on demand, here we use it at template construction time</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> books <span class="pl-k">=</span> [{<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>First Book<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>John Doe<span class="pl-pds">"</span></span>}, {<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>...<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>...<span class="pl-pds">"</span></span>}];
<span class="pl-k">var</span> fuzzyhound <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FuzzySearch</span>({source<span class="pl-k">:</span>books, keys<span class="pl-k">:</span>[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>] });

$(<span class="pl-s"><span class="pl-pds">'</span>#typeahead-input<span class="pl-pds">'</span></span>).typeahead({
            minLength<span class="pl-k">:</span> <span class="pl-c1">2</span>,
            highlight<span class="pl-k">:</span> <span class="pl-c1">false</span> <span class="pl-c">//let FuzzySearch handle highlight</span>
        },
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>books<span class="pl-pds">'</span></span>,
            source<span class="pl-k">:</span> fuzzyhound,
            templates<span class="pl-k">:</span> {
                <span class="pl-en">suggestion</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">result</span>){<span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>&lt;div&gt;<span class="pl-pds">"</span></span><span class="pl-k">+</span>fuzzyhound.highlight(result.<span class="pl-c1">title</span>)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">"</span> by <span class="pl-pds">"</span></span><span class="pl-k">+</span>fuzzyhound.highlight(result.author)<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">"</span>&lt;/div&gt;<span class="pl-pds">"</span></span>}
            }
        });</pre></div>

<h2>
<a id="how-is-this-library-different-" class="anchor" href="#how-is-this-library-different-" aria-hidden="true"><span class="octicon octicon-link"></span></a>How is this library different ?</h2>

<ul>
<li><p>Scoring each item as a sentence instead of a single word is probably a good selling point, even if you do not need more advanced input/output capabilities.
And while the extra loops are not that hard, the algorithm used for the character-by-character "hot loop" support scoring multiple query in parallel, so we are very efficient at solving this task.</p></li>
<li><p>We use bit-parallelism to have a very compact representation of the problem  and speed-up the search.  The idea is that changing one bit or changing 32 bit in an integer take the same amount of time. This basically mean we can search for a 2 character words or 30 character words with the same amount of computation. However 30 character words are quite rare. So we use a modified algorithm that pack multiple words in the same query. For example we could pack six 5 characters words in the same query in the above mentioned hot loop.</p></li>
<li><p>Have more than 32 chars ? No problem ! We'll use as many bit-packed query as you need to search for the whole data. Have a single word bigger than 32 char ? A <code>System.Namespace.Library.something.field</code> symbol maybe ? No problem, we got you covered and we'll transparently switch to an non bit-vector based implementation. </p></li>
<li><p>However, focus on speed is not there to be frugal or beat benchmarks, instead we use it to compute more things and try to be as user-friendly as possible with the computation budget.</p></li>
<li><p>Scoring is based on a exact problem like <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein edit distance</a>,
but we focus on similarities instead of distance, using <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem">Longest common subsequence</a>.
When searching from a list of string with different length, there's quite a bit of difference between <code>the most similar</code> and the <code>least errors</code>. We believe looking at similarities give intuitive results for an autocomplete scenario. (you can see a discussion about scoring below)</p></li>
</ul>

<h2>
<a id="a-note-about-speed" class="anchor" href="#a-note-about-speed" aria-hidden="true"><span class="octicon octicon-link"></span></a>A note about speed</h2>

<p>There's a few way to achieve speed in javascript. One common pattern is to cache quantities that don't change out of loop. Another way is to understand that modern browser will optimize javascript, but have to switch to slower version of the code when javascript behave away from statically typed language, this is one reason you'll see jsdoc type annotation in this project.</p>

<p>But the most important contribution to speed is algorithm: we can try to find a fast way to compute something, but we can gain more if we find something else, easier to compute, that is somehow equivalent. However fast case often only cover a specialized case. So for that reason we provide 4 different algorithms that solve similar problem (scoring a single keywords, scoring multiple keyword in parallel, scoring long keywords, highlight). There's no configuration, we'll switch transparently to the best algorithm for the task, so whatever you are trying to do there's some fast path for it. </p>

<h1>
<a id="scoring-overview" class="anchor" href="#scoring-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scoring overview</h1>

<p>General principle is to be very flexible in finding a match, prefer return a loose match than nothing, but give higher score when we do not need the flexibility (more exact match)</p>

<h2>
<a id="scoring-an-item" class="anchor" href="#scoring-an-item" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scoring an item</h2>

<p>FuzzySearch support quite complex items, query is compared to specified field.
Suppose we have an array of books, where each book looks like this:</p>

<div class="highlight highlight-javascript"><pre>    book <span class="pl-k">=</span> {
        Title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Cliché à Paris, The<span class="pl-pds">"</span></span>,
        Year<span class="pl-k">:</span> <span class="pl-c1">1977</span>,
        Author<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>John MiddleName Doe<span class="pl-pds">"</span></span>,
        Keywords<span class="pl-k">:</span>[<span class="pl-s"><span class="pl-pds">"</span>Story<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Boy<span class="pl-pds">"</span></span>],
        Reference<span class="pl-k">:</span>{ISSN<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>00-11-22<span class="pl-pds">"</span></span>, ARK<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>AA-BB-CC<span class="pl-pds">"</span></span>},
        Available<span class="pl-k">:</span><span class="pl-c1">4</span>
    }</pre></div>

<h3>
<a id="collect-information-and-normalize" class="anchor" href="#collect-information-and-normalize" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collect information (And normalize)</h3>

<p>First step is to tell FuzzySearch what key to index:  </p>

<ul>
<li>
<code>keys = "" or [] or undefined</code> This indicate source is a list of string, index item directly<br>
</li>
<li>
<code>keys = "title" or ["title"]</code> This indicate index a single field <code>title</code><br>
</li>
<li>
<code>keys = ["title","author.fullname"]</code> This indicate index multiple fields</li>
<li>
<code>keys = {title:"title",author:"author.fullname"}</code> This indicate index multiple fields and setup aliases/tags</li>
</ul>

<p>for all the above syntax you can optionally add a path prefix <code>item.</code>: all the following are equivalent: <code>title</code>, <code>.title</code> , <code>item.title</code></p>

<h4>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h4>

<p>With the above book object and this set of keys:</p>

<div class="highlight highlight-javascript"><pre>keys <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>Title<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Author<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Keywords<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Reference.ISSN<span class="pl-pds">"</span></span>]</pre></div>

<p>First thing we do is to build a list of field values. Then normalize the text to lowercase and with some common accent removed. If field is an array all it's sub elements are inserted. Values are inserted for a key value map.
We nested path (things.this.that).</p>

<div class="highlight highlight-javascript"><pre>Fields <span class="pl-k">=</span> [ [<span class="pl-s"><span class="pl-pds">"</span>cliche a paris, the<span class="pl-pds">"</span></span>],
           [<span class="pl-s"><span class="pl-pds">"</span>john middlename doe<span class="pl-pds">"</span></span>],
           [<span class="pl-s"><span class="pl-pds">"</span>1977<span class="pl-pds">"</span></span>],
           [<span class="pl-s"><span class="pl-pds">"</span>story<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>boy<span class="pl-pds">"</span></span>],
           [<span class="pl-s"><span class="pl-pds">"</span>00-11-22<span class="pl-pds">"</span></span>]
           ]</pre></div>

<h4>
<a id="wildcard" class="anchor" href="#wildcard" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wildcard</h4>

<p>Note: you can use the Wildcard <code>*</code> to process array of objects or dictionary of objects <code>myArray.*.property</code> is equivalent of adding</p>

<div class="highlight highlight-javascript"><pre>    myArray.<span class="pl-c1">0</span>.property
    myArray.<span class="pl-c1">1</span>.property
      ...
    myArray.N.property</pre></div>

<h3>
<a id="field-priority" class="anchor" href="#field-priority" aria-hidden="true"><span class="octicon octicon-link"></span></a>Field priority</h3>

<p>It often make send to give more weight to the title than first keyword,
more weight to first keyword than second and so on.</p>

<p>This is achieved using an exponentially decaying bonus. First item have twice the score then bonus decay to one. This is it give a marked difference between first and second item and not so much item 4th going on.</p>

<p>Parameter (<code>d = bonus_position_decay</code>) control the decay:</p>

<div class="highlight highlight-javascript"><pre>bonus <span class="pl-k">=</span> <span class="pl-c1">1.0</span><span class="pl-k">+</span>d<span class="pl-k">^</span>n</pre></div>

<table>
<thead>
<tr>
<th>Position</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bonus (d=0.5)</td>
<td>2.0</td>
<td>1.5</td>
<td>1.25</td>
<td>1.13</td>
<td>1.06</td>
<td>1.03</td>
<td>1.02</td>
<td>1.01</td>
<td>1.003</td>
</tr>
<tr>
<td>Bonus (d=0.7071)</td>
<td>2.0</td>
<td>1.7</td>
<td>1.5</td>
<td>1.35</td>
<td>1.25</td>
<td>1.18</td>
<td>1.13</td>
<td>1.09</td>
<td>1.063</td>
</tr>
</tbody>
</table>

<h3>
<a id="free-word-order" class="anchor" href="#free-word-order" aria-hidden="true"><span class="octicon octicon-link"></span></a>Free word order</h3>

<p>Often words keep their meaning even when out of order.
Those will all match the author keyword:</p>

<pre><code>John Doe
Doe John
John doe Midle
</code></pre>

<p>Another example where free word order is useful would be natural language query:
Match:  <code>How to paint my wall ?</code> against <code>Wall painting 101</code></p>

<p>Flip side of allowing free word order is preferring properly ordered words. This is done by giving a bonus of (<code>bonus_token_order</code>) each time two consecutive token in the query are in order in the match</p>

<h3>
<a id="multiple-field-matching" class="anchor" href="#multiple-field-matching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple field matching</h3>

<p>This query would match in both <code>title</code> and <code>year</code> field:</p>

<blockquote>
<p>cliche 1977</p>
</blockquote>

<p>Flip side of allowing Multiple field matching is giving preference to words in the same field:</p>

<blockquote>
<p>"john doe", two word, same field</p>
</blockquote>

<p>Score is average of</p>

<ol>
<li>best score, every query token on the best field for the item</li>
<li>best score, every query token on any field (their best field)</li>
</ol>

<h3>
<a id="tagged-search" class="anchor" href="#tagged-search" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tagged search</h3>

<p>By default any query keyword can match against any field, but you can use tagged search syntax to specify which field to match. </p>

<blockquote>
<p><strong>fieldname:</strong> my specific query<br>
part that match any field <strong>fieldname:</strong> match specific field<br>
match any <strong>fieldname:</strong> match1 <strong>fieldtwo:</strong> match another  </p>
</blockquote>

<p>Anything before <code>field:</code> separator perform normal match. Everything after a separator, up to the next one, match only on specified field.
We recognize reserved field name and will treat <code>something-else:</code> as a normal word rather than a separator.</p>

<p>Field name come from key path, this example produce separator <code>title:</code> and <code>author.fullName:</code>  </p>

<div class="highlight highlight-javascript"><pre>keys <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>title<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>author.fullName<span class="pl-pds">'</span></span>]</pre></div>

<p>You can use alias feature to specify how you want to name each field, this example produce separator <code>title:</code> and <code>author:</code>  </p>

<div class="highlight highlight-javascript"><pre>keys <span class="pl-k">=</span> {title<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>title<span class="pl-pds">'</span></span>,author<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>author.fullName<span class="pl-pds">'</span></span>}</pre></div>

<h3>
<a id="output-map" class="anchor" href="#output-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Output map</h3>

<h4>
<a id="get-score-detail-searchresult-object" class="anchor" href="#get-score-detail-searchresult-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get Score detail (SearchResult object)</h4>

<p>Setting <code>output_map="root"</code> return the object as we use internally for sorting and scoring</p>

<div class="highlight highlight-javascript"><pre>    result <span class="pl-k">=</span> {
        score<span class="pl-k">:</span><span class="pl-c1">8.1</span>,
        item<span class="pl-k">:</span>{}, <span class="pl-c">//original item</span>
        matchIndex<span class="pl-k">:</span><span class="pl-c1">2</span>
        sortkey<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>...<span class="pl-pds">"</span></span>
    }</pre></div>

<p>you can use <code>instance.getMatchingField(result)</code> to recover matching field.</p>

<h4>
<a id="get-original-object" class="anchor" href="#get-original-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get Original object</h4>

<p>Setting <code>output_map="item"</code> or <code>output_map="root.item"</code> give you back original item as given to the algorithm. This indicate you do not need all match detail and allow to skip some step (like finding original spelling of matching field)</p>

<h4>
<a id="get-a-field-from-the-original-object" class="anchor" href="#get-a-field-from-the-original-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get a field from the original object</h4>

<p>If you only need the id or title of the original item you can do it like that <code>output_map="item.property"</code> or <code>output_map="root.item.property"</code></p>

<h4>
<a id="use-custom-output-object-aliases" class="anchor" href="#use-custom-output-object-aliases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Use custom output object (Aliases)</h4>

<p>To achieve that, you need to set <code>keys</code> option to a dictionary of <code>{output:input}</code> and set <code>output_map="alias"</code>. In that case we'll produce the requested format for you. If output is an array we'll apply <code>options.join_str</code> to join the elements (default to <code>", "</code>)</p>

<p>Example Input: </p>

<div class="highlight highlight-javascript"><pre>    keys <span class="pl-k">=</span> {
        title<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>item.title<span class="pl-pds">"</span></span>,
        authors<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>item.authors.*.Fullname<span class="pl-pds">"</span></span>,
    }</pre></div>

<p>Example output: </p>

<div class="highlight highlight-javascript"><pre>    result <span class="pl-k">=</span> {
        title<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Some book<span class="pl-pds">"</span></span>,
        authors<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>John Doe, Someone Else<span class="pl-pds">"</span></span>,
        _match<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>John Doe<span class="pl-pds">"</span></span>,
        _score<span class="pl-k">:</span><span class="pl-c1">8</span>,
        _item<span class="pl-k">:</span> {<span class="pl-c">/*original object*/</span>}
    }</pre></div>

<p>As you can see we append match detail to the end of custom output. Do not use those name in the key value map or they'll get overwritten.</p>

<h3>
<a id="output-score-threshold" class="anchor" href="#output-score-threshold" aria-hidden="true"><span class="octicon octicon-link"></span></a>Output score threshold</h3>

<p>Default value are for suggestion as you type. In this case we prefer to show poor matches than nothing, match will improve as we type more.</p>

<blockquote>
<p>Parameter <code>thresh_include</code> control the minimum score to show</p>
</blockquote>

<p>We also want to limit choices to a good match or a few good matches if those exist. For example if the best score is twice as good as the next best one, it's obviously the candidate to show.</p>

<blockquote>
<p>Parameter <code>thresh_relative_to_best</code> control ratio of best match needed to be shown on the list</p>
</blockquote>

<p>Lastly if an item have multiple keyword, we might want to stop searching once we have found a good keyword. If a match is this good it'll be shown, no matter the best threshold.</p>

<blockquote>
<p>Parameter <code>field_good_enough</code> control the score needed to stop the search on this item. It also control forced inclusion, not matter best</p>
</blockquote>

<h2>
<a id="scoring-a-token-in-a-auto-complete-friendly-manner" class="anchor" href="#scoring-a-token-in-a-auto-complete-friendly-manner" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scoring a token (in a auto-complete friendly manner)</h2>

<p>There's two main way to count string similarity one is to count the number of matches the other one is to count the number of error. Those refer to the length of the longest common sub-sequence and the edit distance problem. (Here we'll consider only the simple edit distance with only insertion/deletion )</p>

<p>Match are show with "|" and error are show with "-"</p>

<pre><code>sur-ve-y
|||  | |
surg-ery
</code></pre>

<p>match: 5, error: 3</p>

<p>Both are related, but when comparing score of different length they can lead to different conclusions.</p>

<pre><code>match("uni","university") : match 3, error 7
match("uni","hi") : match 1, error 2
</code></pre>

<p>First pairing have more match, second pairing have less error.
Most algorithm available use edit distance (error)
yet somehow uni -&gt; university is a intuitive match.</p>

<h3>
<a id="looking-at-relative-errors" class="anchor" href="#looking-at-relative-errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Looking at relative errors</h3>

<p>One way to deal with different match length is to normalize error count by the length. Which one? Let's try to compare error count with length of second term...</p>

<pre><code>match("uni","university") : 7 error/10 char = 0,7 error/char
match("uni","hi") : 2 error/3 char = 0,666 error/char
</code></pre>

<p>Second match still have a lower relative error count.
Even worse, the number of relative error are very close...</p>

<pre><code>match("uni","universit") : 6 error 9 char, 0,666 error/char
match("uni","universi") : 5 error 8 char, 0,625 error/char
</code></pre>

<p>At that point pairing decision is now reversed. Relative error is not a very stable score.</p>

<h3>
<a id="different-similarity-metric" class="anchor" href="#different-similarity-metric" aria-hidden="true"><span class="octicon octicon-link"></span></a>Different similarity metric</h3>

<p><strong>Simple edit distance</strong> consider only count the number of insert / delete operation needed to go from string A to string B. For example type/typo are at a distance of 2: <code>del[e], ins[o]</code>.</p>

<p><strong>Levenshtein edit distance</strong> add substitution.  For example type/typo are at a distance of 1: <code>subs[e,o]</code>. It improve over simple distance that wrong character error are not penalized twice. However it loose the ability to prefer transposition.</p>

<p><strong>Damerau edit distance</strong> add transposition operation. This has make a metric that do not over penalize substitution, but also prefer word that had letter swapped (not that simple edit distance had that transposition preference too)</p>

<p>Each time we add operation we have the opportunity to better model the error, but it add computation cost</p>

<h4>
<a id="edit-distance-lower-is-better" class="anchor" href="#edit-distance-lower-is-better" aria-hidden="true"><span class="octicon octicon-link"></span></a>Edit distance (lower is better)</h4>

<table>
<thead>
<tr>
<th align="left">Distance</th>
<th>ed</th>
<th>BULB / BOOB</th>
<th>ed</th>
<th>BULB / BLUB</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Simple</td>
<td>4</td>
<td>
<code>B--ULB Ins[OO]</code><br> <code>BOO--B Del[UL]</code>
</td>
<td>2</td>
<td>
<code>B-ULB Ins[L]</code> <br> <code>BLU-B Del[L]</code>
</td>
</tr>
<tr>
<td align="left">Levenshtein</td>
<td>2</td>
<td>Subs[U,O]<br>Subs[L,O]</td>
<td>2</td>
<td>Subs[U,L]<br>Subs[L,U]</td>
</tr>
<tr>
<td align="left">Damerau</td>
<td>2</td>
<td>Subs[U,O]<br>Subs[L,O]</td>
<td>1</td>
<td>Transpose[U,L]</td>
</tr>
</tbody>
</table>

<h4>
<a id="matching-characters-lcs-higher-is-better" class="anchor" href="#matching-characters-lcs-higher-is-better" aria-hidden="true"><span class="octicon octicon-link"></span></a>Matching characters (LCS, higher is better)</h4>

<table>
<thead>
<tr>
<th align="left">Metric</th>
<th>L</th>
<th>BULB / BOOB</th>
<th>L</th>
<th>BULB / BLUB</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">length of lcs</td>
<td>2</td>
<td>BB</td>
<td>3</td>
<td>BUB or BLB</td>
</tr>
</tbody>
</table>

<p>This metric is interesting for a number of reason. First we can remember the above case of <code>match("uni","university")</code> vs <code>match("uni","hi")</code> : intuitively we tend to count match rather than errors. Then this comparison show that counting match result in a scoring similar to Damerau-Levenshtein. No over-penalty on substitution and partial score for transposition.</p>

<p>Possibly more interesting, length of LCS is fast to compute. Similar in complexity than simple edit distance. Indeed, if we set <code>m: length of string A</code>, <code>n: length of string B</code>, <code>ed: simple edit distance with unit cost</code>. <code>llcs:length of lcs</code>, we have:</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-c1">2</span><span class="pl-k">*</span>llcs <span class="pl-k">=</span> m <span class="pl-k">+</span> n <span class="pl-k">-</span> ed</pre></div>

<p>So basically we can learn from that than:</p>

<ul>
<li>If we have either llcs or simple edit distance we can get compute the other.</li>
<li>The 2 in front of llcs is the reason we do not double penalize substitution.</li>
</ul>

<p>Please note that while <code>find the longest subsequence between A and B</code> and <code>find the shortest edit distance between A and B</code> are equivalent while comparing all of A versus all of B (Global match). They are not equivalent while comparing part of A versus part of B (Local match) or all of A versus part of B (Semi-Global, search a needle in a haystack). This explain that they are different research topic with different typical use.</p>

<p>Furthermore, the resulting score are not equivalent while sorting a list of possible matches of varying length. This is the point we tried to make while comparing <code>"uni"</code> to <code>["hi","university"]</code>. The hypothesis behind this project is that counting matches is more intuitive and should better match user expectation in an interactive user interface.</p>

<h5>
<a id="but-is-there-a-catch-" class="anchor" href="#but-is-there-a-catch-" aria-hidden="true"><span class="octicon octicon-link"></span></a>But, is there a catch ?</h5>

<p>Where simple edit distance can be overly severe, llcs can be overly optimistic.
Matching 3 out of 4 character, or matching 3 out of 40 both give a score of 3.
To some extend we want this (better to show something than nothing).
But, we also want to give better score to better match, so we have to find to include back some information about error.</p>

<h3>
<a id="looking-for-a-score-relative-to-input-length" class="anchor" href="#looking-for-a-score-relative-to-input-length" aria-hidden="true"><span class="octicon octicon-link"></span></a>Looking for a score relative to input length</h3>

<p>Let's consider those three cases:</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-c1">match</span>(<span class="pl-s"><span class="pl-pds">"</span>uni<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>university<span class="pl-pds">"</span></span>)     <span class="pl-c">// case 1</span>
    <span class="pl-c1">match</span>(<span class="pl-s"><span class="pl-pds">"</span>unicorn<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>university<span class="pl-pds">"</span></span>) <span class="pl-c">// case 2</span>
    <span class="pl-c1">match</span>(<span class="pl-s"><span class="pl-pds">"</span>uni<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>ultra-nihilist<span class="pl-pds">"</span></span>) <span class="pl-c">// case 3</span></pre></div>

<p>Let m be the number of matches</p>

<ul>
<li>If we compare m to second word length,

<ul>
<li>we cannot differentiate case 1 and 2. (3/10)</li>
</ul>
</li>
<li>we compare m to first word length,

<ul>
<li>we cannot differentiate case 1 and 3. (3/3)</li>
</ul>
</li>
<li>If we compare m to average of both length,

<ul>
<li> we cannot differentiate case 2 and 3 !! (3/8.5)</li>
</ul>
</li>
</ul>

<p>From that we learn that we want to include both length, but not in the form of arythmetic average of both. We need to do more research !</p>

<h4>
<a id="jarowinkler-distance" class="anchor" href="#jarowinkler-distance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jaro–Winkler distance</h4>

<p>The <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro–Winkler distance </a> is an heuristic algorithm for string matching. It's fast and perform well in different comparison.  In particular the <em>Jaro</em> distance use an approximation of LCS and then report it back to a score ranging from 0-1, combining length of both string. <em>Wrinkler</em> add the idea to give a bonus for common prefix, prefix bonus looks like something that fit well in a auto-complete scenario.</p>

<p>Let's examine a Jaro like score: let <code>m: be number of matches</code>, <code>sa: size of a</code>, <code>sb: size of b</code>.</p>

<div class="highlight highlight-javascript"><pre>    score <span class="pl-k">=</span> (m/sa <span class="pl-k">+</span> m/sb) /<span class="pl-c1">2</span>;</pre></div>

<p>This has some interesting properties:</p>

<ul>
<li>better score if we match more of a.</li>
<li>better score if we match more of b.</li>
<li>minimum score is m/(2a) even if b is infinitely large.</li>
</ul>

<p>We do not have access to a number of transposition like <em>Jaro</em>, BUT lcs restrict matches to those that are in correct order, so we have some transposition effect built-in the value of llcs.</p>

<h4>
<a id="prefix" class="anchor" href="#prefix" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prefix</h4>

<p>There's some very efficient way to compute number of matches between two string, but most of them rely on simplifying the original problem. One such simplification is to only store the score and not the different possible path possible to reach that score.</p>

<p>On the flip side, human most often input start of word rather than something in the middle. Prefix is a common sub-string of both inputs that start at first character. It's fast to compute, and allow to shrink the problem size for llcs computation. We'll add some bonus for common prefix controlled by <code>bonus_match_start</code>. That's the Winkler like part of our scoring algorithm.</p>

<p>Compromise of using exact prefix is that a typo at the start of the word will stop  match, so it can induce a heavy penalty.</p>

<h4>
<a id="matching-multiple-keywords" class="anchor" href="#matching-multiple-keywords" aria-hidden="true"><span class="octicon octicon-link"></span></a>Matching multiple keywords</h4>

<p>For matching a single token, we have a pretty interesting solution. However testing revealed that this scoring scheme gave disproportionate importance to small words. For example matching perfectly <code>of</code> or matching perfectly <code>Honorificabilitudinitatibus</code> both give a score of 1. However one is clearly easier to match than the other.</p>

<p>We'll use the match length as a shortcut to specificity. (Doing this, we assume common words are short to use least amount of effort for a specific communication need).</p>

<p>We multiply Jaro-like score by llcs and the score become:</p>

<div class="highlight highlight-javascript"><pre>    score <span class="pl-k">=</span> <span class="pl-c1">0.5</span><span class="pl-k">*</span>m<span class="pl-k">*</span>(m/sa <span class="pl-k">+</span> m/sb)  <span class="pl-k">+</span> bonus<span class="pl-k">*</span>prefix;</pre></div>

<p>Having m squared give the advantage of even better score for good matches and worse score for bad match. It lower the likelihood of multiple bad match out-score a single good match. A character matched in a good token is now worth more than a character matched in a bad token.</p>

<h1>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h1>

<p>(Please see top of JS file for exact options list)</p>

<table>
<thead>
<tr>
<th align="left">Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">minimum_match</td>
<td>1.0</td>
<td>Minimum score to consider two token are not unrelated</td>
</tr>
<tr>
<td align="left">thresh_include</td>
<td>2.0</td>
<td>To be a candidate score of item must be at least this</td>
</tr>
<tr>
<td align="left">thresh_relative_to_best</td>
<td>0.5</td>
<td>and be at least this fraction of the best score</td>
</tr>
<tr>
<td align="left">field_good_enough</td>
<td>20</td>
<td>If a field have this score stop searching other fields. (field score is before item related bonus)</td>
</tr>
<tr>
<td align="left">bonus_match_start</td>
<td>0.5</td>
<td>Additional value per character in common prefix</td>
</tr>
<tr>
<td align="left">bonus_token_order</td>
<td>2.0</td>
<td>Value of two token properly ordered</td>
</tr>
<tr>
<td align="left">bonus_position_decay</td>
<td>0.7</td>
<td>Exponential decay for position bonus (smaller: more importance to first item)</td>
</tr>
<tr>
<td align="left">score_round</td>
<td>0.1</td>
<td>Two item that have the same rounded score are sorted alphabetically</td>
</tr>
<tr>
<td align="left">highlight_prefix</td>
<td>false</td>
<td>true: force prefix as part of highlight (false: minimum gap slower)</td>
</tr>
<tr>
<td align="left">highlight_bridge_gap</td>
<td>2</td>
<td>display small gap as substitution set to size of gap 0 to disable</td>
</tr>
<tr>
<td align="left">highlight_tk_max_size</td>
<td>64</td>
<td>max size of a token for highlight algorithm (it is BVMAXSIZE(31) for search)</td>
</tr>
<tr>
<td align="left">highlight_before</td>
<td>...</td>
<td>tag to put before the highlight <br> <code>default: &lt;strong class="highlight"&gt;</code>
</td>
</tr>
<tr>
<td align="left">highlight_after</td>
<td>...</td>
<td>after the highlight <br> <code>default: &lt;/strong&gt;</code>
</td>
</tr>
</tbody>
</table>

<h1>
<a id="algorithms" class="anchor" href="#algorithms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Algorithms</h1>

<h2>
<a id="dynamic-programming" class="anchor" href="#dynamic-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dynamic programming</h2>

<p>A very efficient way to solve the longest common substring problem is dynamic programming. We don't use that algorithm for scoring per se, but algorithms we use are clever ways to fill that same table using less efforts, so it's important to understand. (Note that the highlight algorithm is a dynamic programming table that solve a generalization of this problem, where we not only score match but penalize gap.)</p>

<p>|  /  |s|u|r|g|e|r|y| 
|:---:|-|-|-|-|-|-|-| 
|<strong>g</strong>|0|0|0|1|1|1|1| 
|<strong>s</strong>|1|1|1|1|1|1|1| 
|<strong>u</strong>|1|2|2|2|2|2|2| 
|<strong>r</strong>|1|2|3|3|3|3|3| 
|<strong>v</strong>|1|2|3|3|3|3|3| 
|<strong>e</strong>|1|2|3|3|4|4|4| 
|<strong>y</strong>|1|2|3|3|4|4|5|  </p>

<h2>
<a id="bit-parallelism-" class="anchor" href="#bit-parallelism-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bit-Parallelism </h2>

<p>(See Crochemore 2001, Hyyrö 2004)</p>

<p>One clever observation about above problem is that two consecutive cell can only change by up to 1 point. So basically we can store above table row by row table as increase/no-increase for each column. Because there's only two state we can use a single bit per column.</p>

<p>That's efficient storage, but what's great is that this storage trick allow to benefit from hardware that is able to operate on 32 or 64 bit at a time. (Javascript can only use 32 bit integer)</p>

<p>This is an example algorithm.
Let <code>strA</code> be the query, position of each character is recorded for fast search later. Let <code>strB</code> be the entry in the database we are trying to score.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> strA.<span class="pl-c1">length</span>;
<span class="pl-k">var</span> n <span class="pl-k">=</span> strB.<span class="pl-c1">length</span>;
<span class="pl-k">var</span> aMap <span class="pl-k">=</span> {};

<span class="pl-c">// - - - - - - - -</span>
<span class="pl-c">// PRECOMPUTE:</span>
<span class="pl-c">// - - - - - - - -</span>

<span class="pl-c">//Map position of each character of a (first char is lsb, so rigth to left)</span>
<span class="pl-c">// --------------"retcarahc"</span>
<span class="pl-c">// aMap["a"] =  0b000010100</span>

<span class="pl-k">for</span> (i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> m; i<span class="pl-k">++</span>) {
    aMap[strA[i]] |<span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> i)
}

<span class="pl-k">var</span> mask <span class="pl-k">=</span> ( <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> m ) <span class="pl-k">-</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> S <span class="pl-k">=</span> mask, U;

<span class="pl-c">// - - - - - - - -</span>
<span class="pl-c">// For each item</span>
<span class="pl-c">// - - - - - - - -</span>

<span class="pl-c">// Fill LCS dynamic programming table</span>
<span class="pl-c">// bitvetor S record position of increase.</span>
<span class="pl-c">// Whole line computed in parallel !</span>
<span class="pl-c">// (Same cost to update 1 bit or 32)</span>
<span class="pl-c">// See Hyyrö, 2004 with S representing V'</span>

<span class="pl-k">for</span> (j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
    U <span class="pl-k">=</span> S <span class="pl-k">&amp;</span> aMap[strB[j]];
    S <span class="pl-k">=</span> (S <span class="pl-k">+</span> U) | (S <span class="pl-k">-</span> U);
}

S <span class="pl-k">=</span> <span class="pl-k">~</span>S <span class="pl-k">&amp;</span> mask;
<span class="pl-c">//Count the number of bit set (1) in S.</span>
<span class="pl-c">//this give you number of matching character (llcs) in strA, strB.</span>
<span class="pl-c">//We'll see below there's still improvement that can be made to this score.</span></pre></div>

<p>This algorythm allow a performance profile of O(m+n) instead of typical O(m*n).</p>

<h2>
<a id="multiple-string-in-parralel-" class="anchor" href="#multiple-string-in-parralel-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple string in parralel </h2>

<p>(See Hyyrö &amp; Navarro 2006)</p>

<p>Processing 32 character at the cost of 1 looks like a huge speed up. Until you realize english words are more like 5 character long. A natural question to ask then is : would it be possible to pack multiple words, as if it where a larger one, and still keep separate score ?</p>

<p>Indeed it is with some modification, hot loop become:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">for</span> (j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> n; j<span class="pl-k">++</span>) {
    U <span class="pl-k">=</span> S <span class="pl-k">&amp;</span> aMap[strB[j]];
    S <span class="pl-k">=</span> (S<span class="pl-k">&amp;</span><span class="pl-c1">ZM</span> <span class="pl-k">+</span> U<span class="pl-k">&amp;</span><span class="pl-c1">ZM</span>) | (S <span class="pl-k">-</span> U);
}

S <span class="pl-k">=</span> <span class="pl-k">~</span>S <span class="pl-k">&amp;</span> mask;
<span class="pl-c">//Count the number of bit set (1) in each region of S.</span></pre></div>

<p>With ZM a bit-vector that is 1 inside each words and 0 at word boundary (that is the last character of each word in this case). There's 6 operations instead of 4 so we can score n words* at the cost of 1.5 (*as long as total length is less than 32)</p>

<p>Quote from (Hyyrö 2006) with symbol renamed to fit code. <code>S[m]</code> refer to the m th bit of S.</p>

<blockquote>
<p>We first note that subtracting the vector <code>U =  S &amp; aMap</code> from  <code>S</code> does not create any carry effects. So the only possible source of interference between different bit regions is the addition  <code>S + U</code> ,  and this can be fixed by changing the addition into the form <code>( S &amp; ZM ) + ( U &amp; ZM )</code>.  To confirm that this modification does not affect the correct behaviour of the algorithm,  we note the following: If  <code>S[m] = 0</code> before the addition, then also <code>U[m] = 0</code> and the modification has no effect. If  <code>S [m] = 1</code> and <code>U[m] = 1</code> before the addition, then the first m bits of the result are the same: the modification just removes the (m +1)th carry bit. Finally, if  <code>S[m] = 1</code> and <code>U[m] = 0</code> before the addition, then the m th bit of the result of the addition is not important: the result is anyway <code>|</code> with <code>( S − U )</code>, which has its m th bit set in this case</p>
</blockquote>

<h2>
<a id="position-based-" class="anchor" href="#position-based-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Position Based </h2>

<p>(See Hyyrö 2009)</p>

<p>Similar idea to the bit-vector algorithm, first we find an efficient way to represent the problem and the saving in space translate to a saving in computation time.</p>

<p>We'll still record position where dynamic programming table increase, but instead of recording it as a bit position, we record it as a number, allowing to go over 32 characters limitation.</p>

<p>More precisely we'll store sequence of consecutive increase instead of each increase one by one. Those sequence naturally arise when there's sequence of consecutive character that match. (This allow to speed up region of high similarity)</p>

<p>One the block is formed it'll act as a single unit for the rest of computation.  The algorithm also take advantage of region without matches by not registering block at those region.</p>

<pre><code>    s u r g e r y
 g [0,0,0,1,1,1,1] : [3,4] (Add level 1)
 s [1,1,1,1,1,1,1] : [0,1] (Make level 1 happens sooner)
 u [1,2,2,2,2,2,2] : [0,2] (Add level 2, append to block of consecutive increase)
 r [1,2,3,3,3,3,3] : [0,3] (Add level 3, append to block of consecutive increase)
 v [1,2,3,3,3,3,3] : [0,3] (v not in surgery, copy)
 e [1,2,3,3,4,4,4] : [0,3],[4,5] (Add level 4, create new block for it)
 y [1,2,3,3,4,4,5] : [0,3],[4,5],[6,7] (Add level 5, create new block for it)

</code></pre>

<pre><code>  12345678901234567890   Position (for this demo we start at 1)
  ii------iii---i--i--   Increase point of previous line
  12222222345555666777   Score previous line [1,3] [9,12] [15,16] [18,19]
  ---m-m---------m---m   Match of this line
  12233333345555677778   Score of this line [1,3] [4,5] [10,12] [15,17] [20,21]
  ii-i-----ii---ii---i   New increase point
  12345678901234567890   Position
</code></pre>

<ul>
<li>
<p>There is 2 Basic operations:</p>

<ul>
<li>Make a level-up happens sooner</li>
<li>Add an extra level up at the end. (this is where llcs increase !)</li>
</ul>
</li>
<li>
<p>Two consecutive increase point without match between them ?</p>

<ul>
<li>Copy from last line.</li>
</ul>
</li>
<li>
<p>An increase point and a match at the same position ?</p>

<ul>
<li>Copy from last line.</li>
</ul>
</li>
<li>
<p>The pattern that trigger a change from last line is:</p>

<ul>
<li> ** first match between two increase point **</li>
</ul>
</li>
<li><p>Match at position 4 is dominant, it make the value increase form 2 to 3.
Match at position 6 is recessive, it also make value from 2 to 3 BUT value for the line was already 3.
     All thing considered that match point could have been removed</p></li>
<li>
<p>When registering a dominant match, we'll either</p>

<ul>
<li>grow an existing block if the math happens right after one</li>
<li>start a new block.</li>
</ul>
</li>
<li><p>Because match make increase point happens sooner
we also need to remove one increase point from following block.
if the initial length was 1, the length is now 0 and block is skipped
otherwise it is copied to current line.</p></li>
</ul>

<h1>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h1>

<p>Main bit-parallel algorithm</p>

<blockquote>
<p>A fast and practical bit-vector algorithm for the longest common sub-sequence problem (Crochemore 2001)
igm.univ-mlv.fr/~mac/REC/DOC/01-lcs_ipl.ps</p>

<p>Bit-parallel LCS-length computation revisited (Hyyrö 2004)
<a href="http://www.sis.uta.fi/%7Ehh56766/pubs/awoca04.pdf">http://www.sis.uta.fi/~hh56766/pubs/awoca04.pdf</a></p>
</blockquote>

<p>Pack multiple token into a single parallel computation</p>

<blockquote>
<p>Increased Bit-Parallelism
for Approximate and Multiple String Matching (Hyyrö 2006)
<a href="http://www.dcc.uchile.cl/%7Egnavarro/ps/jea06.pdf">http://www.dcc.uchile.cl/~gnavarro/ps/jea06.pdf</a></p>
</blockquote>

<p>Large string algorithm (used when previous algorithm would require &gt;32 bit)</p>

<blockquote>
<p>An input sensitive online algorithm for LCS computation (Hyyrö 2009)
<a href="http://www.stringology.org/event/2009/p18.html">http://www.stringology.org/event/2009/p18.html</a>
<a href="http://www.stringology.org/event/2009/psc09p18_presentation.pdf">http://www.stringology.org/event/2009/psc09p18_presentation.pdf</a></p>
</blockquote>

<p>Sequence alignment (highlight)</p>

<blockquote>
<p>Smith Waterman Gotoh
<a href="http://www.bioinf.uni-freiburg.de/Lehre/Courses/2014_SS/V_Bioinformatik_1/gap-penalty-gotoh.pdf">http://www.bioinf.uni-freiburg.de/Lehre/Courses/2014_SS/V_Bioinformatik_1/gap-penalty-gotoh.pdf</a>
<a href="http://telliott99.blogspot.ca/2009/08/alignment-affine-gap-penalties_08.html">http://telliott99.blogspot.ca/2009/08/alignment-affine-gap-penalties_08.html</a></p>
</blockquote>

<p>Comparison of some string similarity measurements</p>

<blockquote>
<p><a href="https://asecuritysite.com/forensics/simstring">https://asecuritysite.com/forensics/simstring</a></p>
</blockquote>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
